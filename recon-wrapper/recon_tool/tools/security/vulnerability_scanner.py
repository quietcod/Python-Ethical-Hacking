"""
Vulnerability Scanner
CVE detection and security vulnerability assessment
"""

import json
import logging
import subprocess
from pathlib import Path
from typing import Dict, Any, List

from ...core.exceptions import ScanError
from ...core.utils import check_tool_installed


class VulnerabilityScanner:
    """CVE and vulnerability assessment scanner"""
    
    def __init__(self, output_dir: Path, config: Dict[str, Any], logger: logging.Logger):
        self.output_dir = output_dir
        self.config = config
        self.logger = logger
        
        # Create vulnerabilities output directory
        self.vulns_dir = output_dir / 'vulnerabilities'
        self.vulns_dir.mkdir(exist_ok=True)
        
    def scan_vulnerabilities(self, target: str) -> Dict[str, Any]:
        """Run comprehensive vulnerability assessment"""
        self.logger.info(f"Starting vulnerability scan for {target}")
        
        results = {
            'target': target,
            'nmap_vulners': {},
            'nuclei_scan': {},
            'nmap_vuln_scripts': {},
            'vulnerability_count': 0,
            'critical_count': 0,
            'high_count': 0,
            'medium_count': 0,
            'low_count': 0
        }
        
        try:
            # Nmap vulnerability scripts
            self._run_nmap_vulnerability_scripts(target, results)
            
            # Nmap with vulners script
            self._run_nmap_vulners(target, results)
            
            # Nuclei vulnerability scanner
            self._run_nuclei_scan(target, results)
            
            # Count vulnerabilities by severity
            self._count_vulnerabilities(results)
            
            # Save results
            self._save_vulnerability_results(target, results)
            
        except Exception as e:
            self.logger.error(f"Vulnerability scan failed: {str(e)}")
            results['error'] = str(e)
        
        return results
    
    def _run_nmap_vulnerability_scripts(self, target: str, results: Dict[str, Any]) -> None:
        """Run Nmap with built-in vulnerability scripts"""
        try:
            if not check_tool_installed('nmap'):
                self.logger.warning("Nmap not available for vulnerability scanning")
                results['nmap_vuln_scripts']['error'] = 'tool_not_available'
                return
            
            self.logger.info(f"Running Nmap vulnerability scripts on {target}")
            
            output_file = self.vulns_dir / f'{target}_nmap_vuln_scripts.xml'
            
            # Common vulnerability detection scripts
            vuln_scripts = [
                'vuln',  # General vulnerability detection
                'vulscan',  # If available
                'ssl-cert',
                'ssl-enum-ciphers',
                'http-sql-injection',
                'http-xssed',
                'ftp-anon',
                'smtp-vuln-cve2010-4344',
                'smb-vuln-ms17-010',
                'smb-vuln-ms08-067'
            ]
            
            script_string = ','.join(vuln_scripts)
            
            cmd = [
                'nmap',
                '-sV',
                '--script', script_string,
                '--script-args', 'unsafe=1',
                '-oX', str(output_file),
                '-oN', str(output_file).replace('.xml', '.txt'),
                target
            ]
            
            # Add timeout
            timeout = self.config.get('vulnerability', {}).get('nmap_timeout', 600)
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout
            )
            
            if result.returncode == 0:
                results['nmap_vuln_scripts'] = {
                    'status': 'completed',
                    'output_file': str(output_file),
                    'scripts_used': vuln_scripts
                }
                
                # Parse XML output for vulnerabilities
                vulns = self._parse_nmap_xml_vulnerabilities(output_file)
                if vulns:
                    results['nmap_vuln_scripts']['vulnerabilities'] = vulns
                    
                self.logger.info(f"Nmap vulnerability scripts completed")
            else:
                results['nmap_vuln_scripts'] = {
                    'status': 'failed',
                    'error': result.stderr.strip() if result.stderr else 'Unknown error'
                }
                
        except subprocess.TimeoutExpired:
            self.logger.warning("Nmap vulnerability scripts timed out")
            results['nmap_vuln_scripts'] = {
                'status': 'timeout',
                'error': 'Scan timed out'
            }
        except Exception as e:
            self.logger.error(f"Nmap vulnerability scripts error: {str(e)}")
            results['nmap_vuln_scripts'] = {
                'status': 'error',
                'error': str(e)
            }
    
    def _run_nmap_vulners(self, target: str, results: Dict[str, Any]) -> None:
        """Run Nmap with vulners script for CVE detection"""
        try:
            if not check_tool_installed('nmap'):
                self.logger.warning("Nmap not available for vulners scan")
                results['nmap_vulners']['error'] = 'tool_not_available'
                return
            
            self.logger.info(f"Running Nmap vulners script on {target}")
            
            output_file = self.vulns_dir / f'{target}_vulners.xml'
            
            cmd = [
                'nmap',
                '-sV',
                '--script=vulners',
                '--script-args', 'mincvss=5.0',  # Only show CVEs with CVSS >= 5.0
                '-oX', str(output_file),
                '-oN', str(output_file).replace('.xml', '.txt'),
                target
            ]
            
            timeout = self.config.get('vulnerability', {}).get('vulners_timeout', 300)
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout
            )
            
            if result.returncode == 0:
                results['nmap_vulners'] = {
                    'status': 'completed',
                    'output_file': str(output_file)
                }
                
                # Parse CVEs from output
                cves = self._parse_vulners_output(output_file)
                if cves:
                    results['nmap_vulners']['cves'] = cves
                    
                self.logger.info(f"Nmap vulners scan completed")
            else:
                results['nmap_vulners'] = {
                    'status': 'failed',
                    'error': result.stderr.strip() if result.stderr else 'Unknown error'
                }
                
        except subprocess.TimeoutExpired:
            self.logger.warning("Nmap vulners scan timed out")
            results['nmap_vulners'] = {
                'status': 'timeout',
                'error': 'Scan timed out'
            }
        except Exception as e:
            self.logger.error(f"Nmap vulners scan error: {str(e)}")
            results['nmap_vulners'] = {
                'status': 'error',
                'error': str(e)
            }
    
    def _run_nuclei_scan(self, target: str, results: Dict[str, Any]) -> None:
        """Run Nuclei vulnerability scanner"""
        try:
            if not check_tool_installed('nuclei'):
                self.logger.warning("Nuclei not available")
                results['nuclei_scan']['error'] = 'tool_not_available'
                return
            
            self.logger.info(f"Running Nuclei scan on {target}")
            
            output_file = self.vulns_dir / f'{target}_nuclei.json'
            
            # Prepare target URL
            if not target.startswith('http'):
                target_url = f"http://{target}"
            else:
                target_url = target
            
            cmd = [
                'nuclei',
                '-target', target_url,
                '-json',
                '-output', str(output_file),
                '-severity', 'medium,high,critical',  # Focus on important findings
                '-rate-limit', '10',  # Be gentle
                '-timeout', '10'
            ]
            
            # Add additional nuclei options from config
            nuclei_config = self.config.get('vulnerability', {}).get('nuclei', {})
            
            if nuclei_config.get('update_templates', True):
                # Update templates before scanning
                update_cmd = ['nuclei', '-update-templates']
                subprocess.run(update_cmd, capture_output=True, timeout=60)
            
            if nuclei_config.get('exclude_tags'):
                cmd.extend(['-exclude-tags', ','.join(nuclei_config['exclude_tags'])])
            
            timeout = nuclei_config.get('timeout', 300)
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout
            )
            
            results['nuclei_scan'] = {
                'status': 'completed',
                'output_file': str(output_file),
                'return_code': result.returncode
            }
            
            # Parse Nuclei JSON output
            if output_file.exists():
                nuclei_vulns = self._parse_nuclei_output(output_file)
                if nuclei_vulns:
                    results['nuclei_scan']['vulnerabilities'] = nuclei_vulns
                    
            self.logger.info(f"Nuclei scan completed")
                
        except subprocess.TimeoutExpired:
            self.logger.warning("Nuclei scan timed out")
            results['nuclei_scan'] = {
                'status': 'timeout',
                'error': 'Scan timed out'
            }
        except Exception as e:
            self.logger.error(f"Nuclei scan error: {str(e)}")
            results['nuclei_scan'] = {
                'status': 'error',
                'error': str(e)
            }
    
    def _parse_nmap_xml_vulnerabilities(self, xml_file: Path) -> List[Dict[str, Any]]:
        """Parse Nmap XML output for vulnerabilities"""
        vulnerabilities = []
        
        try:
            if not xml_file.exists():
                return vulnerabilities
            
            # Simple text parsing as fallback
            txt_file = xml_file.with_suffix('.txt')
            if txt_file.exists():
                with open(txt_file, 'r') as f:
                    content = f.read()
                
                # Look for vulnerability indicators
                lines = content.split('\n')
                current_vuln = None
                
                for line in lines:
                    line = line.strip()
                    
                    # Look for CVE references
                    if 'CVE-' in line:
                        cve_match = line
                        vulnerabilities.append({
                            'type': 'CVE',
                            'description': cve_match,
                            'severity': 'unknown',
                            'source': 'nmap'
                        })
                    
                    # Look for vulnerability script results
                    elif 'VULNERABLE:' in line.upper():
                        vulnerabilities.append({
                            'type': 'vulnerability',
                            'description': line,
                            'severity': 'medium',
                            'source': 'nmap'
                        })
            
        except Exception as e:
            self.logger.error(f"Error parsing Nmap XML vulnerabilities: {str(e)}")
        
        return vulnerabilities
    
    def _parse_vulners_output(self, output_file: Path) -> List[Dict[str, Any]]:
        """Parse vulners script output for CVEs"""
        cves = []
        
        try:
            txt_file = output_file.with_suffix('.txt')
            if not txt_file.exists():
                return cves
            
            with open(txt_file, 'r') as f:
                content = f.read()
            
            lines = content.split('\n')
            
            for line in lines:
                line = line.strip()
                
                # Look for CVE entries with CVSS scores
                if 'CVE-' in line and 'cvss' in line.lower():
                    # Extract CVE and CVSS score
                    parts = line.split()
                    cve_id = None
                    cvss_score = None
                    
                    for part in parts:
                        if part.startswith('CVE-'):
                            cve_id = part
                        elif 'cvss:' in part.lower():
                            try:
                                cvss_score = float(part.split(':')[1])
                            except:
                                pass
                    
                    if cve_id:
                        severity = self._cvss_to_severity(cvss_score) if cvss_score else 'unknown'
                        
                        cves.append({
                            'cve_id': cve_id,
                            'cvss_score': cvss_score,
                            'severity': severity,
                            'description': line,
                            'source': 'vulners'
                        })
            
        except Exception as e:
            self.logger.error(f"Error parsing vulners output: {str(e)}")
        
        return cves
    
    def _parse_nuclei_output(self, output_file: Path) -> List[Dict[str, Any]]:
        """Parse Nuclei JSON output"""
        vulnerabilities = []
        
        try:
            if not output_file.exists():
                return vulnerabilities
            
            with open(output_file, 'r') as f:
                content = f.read().strip()
            
            if not content:
                return vulnerabilities
            
            # Nuclei outputs one JSON object per line
            for line in content.split('\n'):
                if line.strip():
                    try:
                        vuln_data = json.loads(line)
                        
                        vulnerability = {
                            'template_id': vuln_data.get('template-id', ''),
                            'name': vuln_data.get('info', {}).get('name', ''),
                            'severity': vuln_data.get('info', {}).get('severity', 'unknown'),
                            'description': vuln_data.get('info', {}).get('description', ''),
                            'matched_at': vuln_data.get('matched-at', ''),
                            'tags': vuln_data.get('info', {}).get('tags', []),
                            'source': 'nuclei'
                        }
                        
                        vulnerabilities.append(vulnerability)
                        
                    except json.JSONDecodeError as e:
                        self.logger.debug(f"Error parsing Nuclei JSON line: {str(e)}")
                        continue
            
        except Exception as e:
            self.logger.error(f"Error parsing Nuclei output: {str(e)}")
        
        return vulnerabilities
    
    def _cvss_to_severity(self, cvss_score: float) -> str:
        """Convert CVSS score to severity level"""
        if cvss_score >= 9.0:
            return 'critical'
        elif cvss_score >= 7.0:
            return 'high'
        elif cvss_score >= 4.0:
            return 'medium'
        elif cvss_score > 0.0:
            return 'low'
        else:
            return 'info'
    
    def _count_vulnerabilities(self, results: Dict[str, Any]) -> None:
        """Count vulnerabilities by severity"""
        severity_counts = {
            'critical': 0,
            'high': 0,
            'medium': 0,
            'low': 0,
            'info': 0
        }
        
        # Count from all sources
        sources = ['nmap_vuln_scripts', 'nmap_vulners', 'nuclei_scan']
        
        for source in sources:
            source_data = results.get(source, {})
            
            # Count from vulnerabilities list
            if 'vulnerabilities' in source_data:
                for vuln in source_data['vulnerabilities']:
                    severity = vuln.get('severity', 'unknown').lower()
                    if severity in severity_counts:
                        severity_counts[severity] += 1
            
            # Count from CVEs list
            if 'cves' in source_data:
                for cve in source_data['cves']:
                    severity = cve.get('severity', 'unknown').lower()
                    if severity in severity_counts:
                        severity_counts[severity] += 1
        
        # Update results
        results['critical_count'] = severity_counts['critical']
        results['high_count'] = severity_counts['high']
        results['medium_count'] = severity_counts['medium']
        results['low_count'] = severity_counts['low']
        results['vulnerability_count'] = sum(severity_counts.values())
    
    def _save_vulnerability_results(self, target: str, results: Dict[str, Any]) -> None:
        """Save vulnerability assessment results"""
        sanitized_target = target.replace(':', '_').replace('/', '_')
        
        # Save JSON results
        json_file = self.vulns_dir / f'{sanitized_target}_vulnerability_results.json'
        with open(json_file, 'w') as f:
            json.dump(results, f, indent=2, default=str)
        
        self.logger.info(f"Vulnerability results saved to {json_file}")
        
        # Create human-readable summary
        txt_file = self.vulns_dir / f'{sanitized_target}_vulnerability_summary.txt'
        
        with open(txt_file, 'w') as f:
            f.write(f"Vulnerability Assessment Summary for {target}\n")
            f.write("=" * 60 + "\n\n")
            
            # Overview
            f.write("Overview:\n")
            f.write(f"  Total Vulnerabilities: {results['vulnerability_count']}\n")
            f.write(f"  Critical: {results['critical_count']}\n")
            f.write(f"  High: {results['high_count']}\n")
            f.write(f"  Medium: {results['medium_count']}\n")
            f.write(f"  Low: {results['low_count']}\n\n")
            
            # Tools used
            f.write("Tools Used:\n")
            for tool in ['nmap_vuln_scripts', 'nmap_vulners', 'nuclei_scan']:
                tool_data = results.get(tool, {})
                status = tool_data.get('status', 'not_run')
                f.write(f"  {tool.replace('_', ' ').title()}: {status}\n")
            f.write("\n")
            
            # Detailed findings
            if results['vulnerability_count'] > 0:
                f.write("Detailed Findings:\n")
                f.write("-" * 40 + "\n\n")
                
                # Nmap vulnerabilities
                nmap_vulns = results.get('nmap_vuln_scripts', {}).get('vulnerabilities', [])
                if nmap_vulns:
                    f.write("Nmap Vulnerability Scripts:\n")
                    for vuln in nmap_vulns:
                        f.write(f"  [{vuln.get('severity', 'unknown').upper()}] {vuln.get('description', 'N/A')}\n")
                    f.write("\n")
                
                # Vulners CVEs
                vulners_cves = results.get('nmap_vulners', {}).get('cves', [])
                if vulners_cves:
                    f.write("CVEs (Vulners):\n")
                    for cve in vulners_cves:
                        f.write(f"  {cve.get('cve_id', 'Unknown')} - CVSS: {cve.get('cvss_score', 'N/A')} [{cve.get('severity', 'unknown').upper()}]\n")
                    f.write("\n")
                
                # Nuclei findings
                nuclei_vulns = results.get('nuclei_scan', {}).get('vulnerabilities', [])
                if nuclei_vulns:
                    f.write("Nuclei Findings:\n")
                    for vuln in nuclei_vulns:
                        f.write(f"  [{vuln.get('severity', 'unknown').upper()}] {vuln.get('name', 'N/A')}\n")
                        f.write(f"    Template: {vuln.get('template_id', 'N/A')}\n")
                        f.write(f"    URL: {vuln.get('matched_at', 'N/A')}\n")
                        if vuln.get('description'):
                            f.write(f"    Description: {vuln['description'][:100]}...\n")
                        f.write("\n")
            else:
                f.write("No vulnerabilities found.\n")
        
        self.logger.info(f"Vulnerability summary saved to {txt_file}")
